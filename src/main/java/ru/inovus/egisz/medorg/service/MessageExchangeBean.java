package ru.inovus.egisz.medorg.service;

import org.apache.commons.lang3.StringUtils;
import org.apache.cxf.headers.Header;
import org.apache.cxf.jaxb.JAXBDataBinding;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import ru.inovus.egisz.medorg.exceptions.EgiszFaultException;
import ru.inovus.egisz.medorg.exceptions.NotReceivedIdException;
import ru.inovus.egisz.medorg.handlers.SOAPMessageSigner;
import ru.inovus.egisz.medorg.rest.RestCallbackCommand;
import ru.inovus.egisz.medorg.rest.XmlAcknowledgeContent;
import ru.inovus.egisz.medorg.rest.XmlFailContent;
import ru.inovus.egisz.medorg.util.ConfigHelper;
import ru.inovus.egisz.medorg.util.ExceptionHelper;
import ru.inovus.egisz.medorg.util.JAXBHelper;
import ru.inovus.egisz.medorg.util.SOAPConfigurator;
import ru.rt.eu.nr.autogenerated.receiver.service.v1_0.*;

import javax.annotation.PostConstruct;
import javax.ejb.*;
import javax.ws.rs.container.AsyncResponse;
import javax.ws.rs.container.CompletionCallback;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.xml.namespace.QName;
import javax.xml.ws.BindingProvider;
import javax.xml.ws.soap.SOAPFaultException;
import java.net.URL;
import java.util.ArrayList;
import java.util.List;

/**
 * Обеспечивает обмен сообщениями между ИС потребителя и ЕГИСЗ ИПС через SOAP
 */
@Singleton
@Lock(LockType.READ)
@DependsOn({"ApplicationStartup"})
public class MessageExchangeBean {

    private static final Logger logger = LoggerFactory.getLogger(MessageExchangeBean.class);

    @EJB
    private MessageInfoService messageInfoService;

    private final static QName SERVICE_QNAME = new QName("http://receiver.service.nr.eu.rt.ru/", "receiver");

    private final static String WSDL_URL = "ru/rt/eu/nr/receiver/service/v1.0.wsdl";

    private static final String WWW_W3_ORG_2005_08_ADDRESSING = "http://www.w3.org/2005/08/addressing";

    private URL wsdlUrl;

    @PostConstruct
    public void init() {

        ClassLoader cl = ConfigHelper.class.getClassLoader();

        /* URL, по которому сервис экспонирует свой WSDL, в виде строки. */
        wsdlUrl = cl.getResource(WSDL_URL);
    }

    /**
     * Отправляет SendDocument-запрос в ЕГИСЗ ИПС
     *
     * @param asyncResponse      объект, который позволяет асинхронно отправлять ответ в другом потоке
     * @param authorizedUserName логин авторизированного пользователя
     * @param ipsEndPoint        url-точки доступа к сервисам ЕГИСЗ ИПС
     * @param oid                идентификатор базового объекта
     * @param service            название сервиса
     * @param base64Document     строка XML-документа перекодированная в Base64
     * @param restCallbackUrl    url - для отправки результата обработки
     */
    public void sendDocument(AsyncResponse asyncResponse, final String authorizedUserName, final String ipsEndPoint, final String oid, final String service, final String base64Document, final String restCallbackUrl) {

        try {

            try {

                /* создание порта точки доступа к сервису обмена сообщениями ЕГИСЗ ИПС */
                Receiver port = new Receiver_Service(wsdlUrl, SERVICE_QNAME).getReceiverPort();

                /* настройка url точки доступа к серверу ЕГИСЗ ИПС */
                SOAPConfigurator.setEndpointURL(port, ipsEndPoint);

                /* настройка Apache CXF, чтобы в заголовках soap-запроса вычислялся Content-Length */
                SOAPConfigurator.сontentLengthActivate(port);

                /* извлекаем из настроек название ИС */
                String informationSystemName = ConfigHelper.getAppProperty(authorizedUserName + ".informationSystemName");

                /* извлекаем из настроек PEM-сертификата ЭП */
                String pemCertificate = ConfigHelper.getAppProperty(authorizedUserName + ".pemCertificate");

                /* извлекаем из настроек PEM-закрытого ключа ЭП */
                String pemPrivateKey = ConfigHelper.getAppProperty(authorizedUserName + ".pemPrivateKey");

                /* подключение SOAPHandler-а для подписи SOAP-сообщений, отправляемых на сервисы ЕГИСЗ ИПС */
                SOAPConfigurator.bindingSOAPHandler(port, new SOAPMessageSigner(informationSystemName, pemCertificate, pemPrivateKey), false);

                /* добавляем в заголовок элементы */
                List<Header> headersList = new ArrayList<>();

                JAXBDataBinding jaxbDataBinding = JAXBHelper.getJAXBDataBinding();

                headersList.add(new Header(new QName(WWW_W3_ORG_2005_08_ADDRESSING, "To", "wsa"), ipsEndPoint, jaxbDataBinding));
                headersList.add(new Header(new QName(WWW_W3_ORG_2005_08_ADDRESSING, "Action", "wsa"), "sendDocument", jaxbDataBinding));

                addHeaders(port, headersList);

                final String egiszRespMessageId = port.sendDocument(oid, service, base64Document);

                if (StringUtils.isBlank(egiszRespMessageId)) {

                    throw new NotReceivedIdException("Не получен id принятого сообщения из ЕГИСЗ ИПС для SendDocument-запроса: authorizedUserName=" + authorizedUserName + ", endPoint=" + ipsEndPoint + ", oid=" + oid + ", service=" + service + ", document=" + base64Document);

                } else {
                    messageInfoService.addMessage(egiszRespMessageId, new RestCallbackCommand(authorizedUserName, restCallbackUrl));

                    logger.debug("MEDORG. Получен id принятого сообщения {} из ЕГИСЗ ИПС для SendDocument-запроса: authorizedUserName={}, endPoint={}, oid={}, service={}, document={}", egiszRespMessageId, authorizedUserName, ipsEndPoint, oid, service, base64Document);

                    asyncResponse.register((CompletionCallback) throwable -> {

                        if (throwable != null) {

                            logger.error("MEDORG. Ошибка при доставке id принятого сообщения ЕГИСЗ ИПС {} потребителю {} для SendDocument-запроса: endPoint={}, oid={}, service={}, document={}", egiszRespMessageId, authorizedUserName, ipsEndPoint, oid, service, base64Document, throwable);

                        } else {

                            if (asyncResponse.isCancelled()) {

                                logger.debug("MEDORG. Прервана доставка id принятого сообщения ЕГИСЗ {} потребителю {} для SendDocument-запроса: endPoint={}, oid={}, service={}, document={}", egiszRespMessageId, authorizedUserName, ipsEndPoint, oid, service, base64Document);

                            } else {

                                logger.debug("MEDORG. Успешно доставлен потребителю {} id принятого сообщения ЕГИСЗ {} для SendDocument-запроса: endPoint={}, oid={}, service={}, document={}", authorizedUserName, egiszRespMessageId, ipsEndPoint, oid, service, base64Document);
                            }
                        }
                    });

                    /* передача потребителю id принятого сообщения ЕГИСЗ ИПС */
                    Response response = Response.ok(new XmlAcknowledgeContent(egiszRespMessageId))
                            .type(MediaType.APPLICATION_XML)
                            .build();

                    asyncResponse.resume(response);
               }

            } catch (SystemFaultException ex) {

                throw new EgiszFaultException("Необработанное исключение ЕГИСЗ ИПС при приёме SendDocument-запроса.", ex);

            } catch (SOAPFaultException | AuthorizationFaultException | ValidationFaultException ex) {

                throw new EgiszFaultException("SendDocument-запрос не прошёл проверку ЕГИСЗ ИПС.", ex);
            }

        } catch (EgiszFaultException | NotReceivedIdException ex) {

            final String errMessage = ex.getMessage() + ExceptionHelper.getMessageOrStackTrace(ex);

            /* Stacktrace не записываем, и так понятно, что выброс исключения выполняется из метода класса SOAPHandler */
            logger.warn("MEDORG. {} : authorizedUserName={}, endPoint={}, oid={}, service={}, document={}", errMessage, authorizedUserName, ipsEndPoint, oid, service, base64Document);

            asyncResponse.register((CompletionCallback) throwable -> {

                if (throwable != null) {

                    logger.error("MEDORG. Ошибка при доставке потребителю {} сообщения об ошибке ЕГИСЗ ИПС для SendDocument-запроса: endPoint={}, oid={}, service={}, document={}", authorizedUserName, ipsEndPoint, oid, service, base64Document, throwable);

                } else {

                    if (asyncResponse.isCancelled()) {

                        logger.debug("MEDORG. Прервана доставка потребителю {} сообщения об ошибке ЕГИСЗ ИПС для SendDocument-запроса: endPoint={}, oid={}, service={}, document={}", authorizedUserName, ipsEndPoint, oid, service, base64Document);

                    } else {

                        logger.debug("MEDORG. Успешно доставлено потребителю {} сообщение об ошибке ЕГИСЗ ИПС для SendDocument-запроса: endPoint={}, oid={}, service={}, document={}", authorizedUserName, ipsEndPoint, oid, service, base64Document);
                    }
                }
            });

            Response response = Response.ok(new XmlFailContent(errMessage))
                    .type(MediaType.APPLICATION_XML)
                    .build();

            asyncResponse.resume(response);
        }
    }

    private void addHeaders(final Receiver port, final List<Header> headersList) {
        ((BindingProvider) port).getRequestContext().put(Header.HEADER_LIST, headersList);
    }

}
